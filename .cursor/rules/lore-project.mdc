---
description: Project identity, agent behavior rules, and coding/docs conventions
alwaysApply: true
---

# Agent Rules

<!-- Injected into every agent session as PROJECT context. -->
<!-- Customize with your project identity and behavior rules. -->
<!-- Coding conventions belong in docs/context/conventions.md — also injected. -->

## About

Describe your project — what it is, what repos are involved, key constraints.

## Agent Behavior

Rules for how the agent should operate in this instance.

# Conventions

Operational rules and standards for this environment. Each page covers a specific domain.

# Coding

## 1. Surface Confusion Early

**Uncertainty hidden is uncertainty compounded.**

- State assumptions before writing code. If uncertain, ask.
- When multiple interpretations exist, present them — don't pick silently.
- If a simpler approach exists, say so. Push back when warranted.
- If requirements are ambiguous, stop and clarify. Don't guess.

## 2. Write Less Code

**The best code is the code you didn't write.**

- Solve exactly what was asked. No speculative features.
- Don't abstract what's used once. Three similar lines beat a premature helper.
- Don't add configurability, extensibility, or error handling for scenarios that can't happen.
- If 200 lines could be 50, rewrite.

## 3. Change Only What You Must

**Every changed line should trace to the request.**

- Don't improve adjacent code, comments, or formatting.
- Don't refactor what isn't broken. Match existing style.
- If you notice unrelated problems, mention them — don't fix them.
- Remove imports, variables, and functions YOUR changes made unused. Leave pre-existing dead code alone.

## 4. Prove It Works

**Untested code is unfinished code.**

- Write or run tests before calling it done. No test framework? Verify manually and show output.
- After two failed fix attempts, stop. Re-read the error, re-read the code, reconsider the approach entirely.
- Check security basics: no hardcoded secrets, no unvalidated input in queries or commands, no exposed internals.

## 5. Plan, Execute, Verify

**Define done. Work toward it. Confirm you got there.**

Transform tasks into verifiable outcomes:

- "Add validation" → write tests for invalid inputs, then make them pass.
- "Fix the bug" → reproduce it with a test, then make it pass.
- "Refactor X" → ensure tests pass before and after.

For multi-step work, state the plan up front:

```
1. [Step] → verify: [how]
2. [Step] → verify: [how]
3. [Step] → verify: [how]
```

# Docs

## 1. Don't Duplicate

**One source of truth per fact. Everything else links.**

- Before writing, check if the information already exists. If it does, link to it.
- If two files say the same thing, delete one and point to the other.
- README, comments, docstrings, and commit messages serve different purposes. Don't repeat content across them.
- If you find yourself copying a paragraph, you're creating a future contradiction.

## 2. Keep It Short

**Say it once, say it clearly, stop.**

- One topic per page. If a doc covers two unrelated things, split it.
- Cut filler: "it should be noted that", "in order to", "as mentioned above." Just state the thing.
- One code example beats a paragraph of explanation.
- If a page exceeds 150 lines, it's probably two pages.

## 3. Don't Let Docs Rot

**Stale docs are worse than no docs.**

- When you change code, update the docs that describe it in the same change.
- If you find a doc that contradicts the code, fix or delete it immediately.
- Don't leave commented-out content, TODO placeholders, or "will be updated later" notes. They never get updated.
- Outdated docs actively mislead. Absence is safer than inaccuracy.

## 4. Don't Create Docs Nobody Asked For

**Docs solve real problems. They are not a deliverable.**

- Don't proactively generate README files, architecture docs, or guides unless requested.
- Don't document what the code already makes obvious. `getUserById(id)` doesn't need a comment.
- Don't add docstrings, type annotations, or inline comments to code you didn't change.
- If you wouldn't read it, don't write it.

## 5. Be Precise

**Vague docs create vague understanding.**

- Use exact names: file paths, function names, CLI commands. Not "the config file" — which one?
- Replace vague pronouns ("it", "this", "that") with the explicit noun when ambiguous.
- Use consistent terminology. Pick one term per concept and stick with it project-wide.
- Concrete over abstract: specific values, real examples, actual commands.

# Knowledge Capture

How knowledge entries should be written and organized. For routing rules (what goes where), see `.lore/instructions.md`.

## 1. One Canonical Location Per Fact

**If changing one fact means editing multiple files, the structure is wrong.**

- Every piece of reference data (IPs, endpoints, service configs) lives in exactly one file. Everything else links to it.
- Before adding information, search for where it already exists. Add to that file or link to it.
- Tables and lists consolidate naturally. Five services on the same platform belong in one table, not five pages.
- When you find duplication, fix it: pick the canonical location, consolidate, replace copies with links.

## 2. Consolidate, Don't Scatter

**A file should earn its existence. Thin files are overhead.**

- If a page is under 30 lines, it's a section in a parent file — not its own page.
- Related services, endpoints, or configs belong in a single reference table. Don't create a page per service when a row per service will do.
- Group by domain, not by when you learned it. "All backup targets" beats "backup-vaultwarden, backup-docker, backup-proxmox, backup-media, backup-offsite, backup-network."
- Runbooks for trivial operations (single command, one config export) belong as entries in a quick-reference list.

## 3. Minimize Update Cost

**Structure for maintainability, not comprehensiveness.**

- Before creating a new file, ask: "If this data changes, how many files do I touch?" If the answer is more than one, restructure.
- Reference data (IPs, ports, VLANs, service URLs) belongs in inventory tables, not embedded in prose across runbooks and plans.
- Runbooks should reference inventory data by link, not by copying it inline.
- When infrastructure changes, one file update should be sufficient.

## 4. Keep It Scannable

**Walls of prose hide information. Structure reveals it.**

- Use tables for anything with repeating attributes (services, VMs, endpoints, backup schedules).
- Use short bullets for facts. Save paragraphs for decisions that need rationale.
- Front-load the key insight. First sentence answers "what do I need to know?"
- Headings should be specific enough to find by scanning. "NFS Configuration" beats "Additional Notes."

## 5. Don't Capture Noise

**Not everything learned is worth persisting.**

- Don't capture session-specific context (current task state, in-progress decisions).
- Don't write knowledge that restates what code or config files already make obvious.
- Don't create entries for hypothetical problems you haven't hit.
- Don't capture what's already in instructions or conventions. Link instead.

# Security

## 1. No Secrets in the Repo

**Credentials, tokens, and keys never touch version control. Period.**

- Never write passwords, API keys, tokens, private keys, or connection strings into any file — docs, code, configs, or comments.
- Don't document "where the password is" with the actual value. Reference the secret manager, vault, or env var name — not the secret itself.
- If you encounter a secret in the repo, flag it immediately. Don't commit over it, move it, or reference it.
- `.env` files, credential JSONs, and key files belong in `.gitignore`. If they're not there, add them before doing anything else.

## 2. Assume Everything Is Visible

**Treat every committed file as public.**

- Even private repos get cloned, forked, shared, and leaked. Write accordingly.
- Don't embed internal URLs with auth tokens in query strings.
- Don't log or capture API responses that contain sensitive data.
- Sanitize examples: use `example.com`, `TOKEN_HERE`, `<your-api-key>` — never real values.

## 3. Validate at Boundaries

**Trust internal code. Verify external input.**

- Validate user input, API request bodies, webhook payloads, and anything from outside the system boundary.
- Don't add defensive validation inside internal function calls that you control.
- Parameterize all database queries. No string concatenation with user input.
- Escape output in the appropriate context (HTML, shell, SQL) before rendering or executing.

## 4. Least Privilege

**Grant the minimum access required. Nothing more.**

- Service accounts, API keys, and tokens should have the narrowest scope possible.
- Don't use admin/root credentials for routine operations.
- When documenting access patterns, note what permissions are required — not how to escalate them.
- Prefer short-lived tokens over long-lived ones. Document rotation procedures, not the tokens themselves.

# Work Items

## Formatting

- **Checkboxes** (`- [x]`/`- [ ]`) for all actionable items: scope, deliverables, success criteria.
- **Strikethrough** (`~~text~~`) on completed item text: `- [x] ~~Done item~~`
- **No emoji icons** — no checkmarks, no colored circles, no decorative symbols.
- **Blank line before lists** — required for MkDocs to render lists correctly.
